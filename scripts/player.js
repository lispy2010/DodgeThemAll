class Player { constructor(x, y) { this.x = x; this.y = y; this.startX = this.x; this.startY = this.y; this.velX = 0; this.velY = 0; this.trails = []; this.hp = 100; this.canBeHit = true; this.move = { left: false, right: false, up: false, down: false, }; this.skin = skins.default; this.skinCreeperColor = false; this.skinRainbowColorIndex = 0; this.skinRainbowColors = [ { r: 255, g: 0, b: 0 }, { r: 255, g: 165, b: 0 }, { r: 255, g: 255, b: 0 }, { r: 0, g: 255, b: 0 }, { r: 0, g: 255, b: 255 }, { r: 0, g: 0, b: 255 }, { r: 255, g: 0, b: 255 } ]; setInterval(() => { this.skinCreeperColor = !this.skinCreeperColor; }, 500); setInterval(() => { this.skinRainbowColorIndex++; if (this.skinRainbowColorIndex >= this.skinRainbowColors.length) { this.skinRainbowColorIndex = 0; } }, 150); document.addEventListener("keydown", ev => { if (ev.key === "ArrowLeft" || ev.key === "a") { this.move.left = true; } if (ev.key === "ArrowRight" || ev.key === "d") { this.move.right = true; } if (ev.key === "ArrowUp" || ev.key === "w") { this.move.up = true; } if (ev.key === "ArrowDown" || ev.key === "s") { this.move.down = true; } if (!beta) { return; } if (ev.key === "F3") { enemies.forEach(e => { e.x = this.x; e.y = this.y; }); } if (ev.key === "F4") { score = nextLevel; } if (ev.key === "F5") { this.hp = 0; } if (ev.key === "F6") { coins.push(new Coin(Math.random() * (canvas.width - 32), Math.random() * (canvas.height - 32))); } if (ev.key === "F7") { for (let i = 0; i < 5; i++) { enemies.push(new SmartEnemy(50 + i * 20, 100)); } } if (ev.key === "F8") { coinCount = Infinity; } if (ev.key == "F9") { enemies.push(new WalkingEnemy(50, 100)); } if (ev.key == "F10") { enemies.push(new BossEnemy(50, 100)); } }); document.addEventListener("keyup", ev => { if (ev.key === "ArrowLeft" || ev.key === "a") { this.move.left = false; } if (ev.key === "ArrowRight" || ev.key === "d") { this.move.right = false; } if (ev.key === "ArrowUp" || ev.key === "w") { this.move.up = false; } if (ev.key === "ArrowDown" || ev.key === "s") { this.move.down = false; } }); } draw() { if (this.gameOver) { return; } if (options.showTrail) { this.trails.forEach(t => { t.draw(); }); } ctx.drawImage(this.skin, this.x, this.y); ctx.fillStyle = "gray"; ctx.fillRect(10, 10, 200, 20); ctx.fillStyle = "lime"; ctx.fillRect(10, 10, this.hp * 2, 20); ctx.strokeStyle = "yellow"; ctx.strokeRect(10, 10, 200, 20); ctx.strokeRect(9, 9, 202, 22); ctx.fillStyle = "yellow"; ctx.font = "8px press-start"; ctx.fillText(`${this.hp}`, 220, 25); ctx.font = "10px press-start"; ctx.fillText(`${lang[options.lang].score} ${score}`, 10, 60); ctx.fillText(`${lang[options.lang].level} ${level}`, 10, 79); ctx.fillText(`${lang[options.lang].nextLevelp1} ${nextLevel} ${lang[options.lang].nextLevelp2}`, 10, 98); ctx.fillText(`${lang[options.lang].coins} ${coinCount}`, 10, 117); } update() { if (this.gameOver) { return; } if (this.hp === 0 && !this.gameOver) { this.gameOver = true; sndGameOver.play(); } this.hp = Math.min(this.hp, 100); this.hp = Math.max(this.hp, 0); score++; scoreTotal++; if (score > nextLevel) { nextLevel += 250; score = 0; level++; screenFlashAlpha = .8; spawnEnemy(); sndNextLevel.play(); } if (this.move.left) { this.velX = -5; } if (this.move.right) { this.velX = 5; } if ((!this.move.left && !this.move.right) || (this.move.left && this.move.right)) { this.velX = 0; } if (this.move.up) { this.velY = -5; } if (this.move.down) { this.velY = 5; } if ((!this.move.up && !this.move.down) || (this.move.up && this.move.down)) { this.velY = 0; } this.x += this.velX; this.y += this.velY; enemies.forEach(e => { if (e.hitbox.intersects(this.hitbox) && this.canBeHit) { if (!e.hitbox.intersects(this.hitboxInner) || e instanceof SmartEnemy || e instanceof BossEnemy) { this.hp -= 3; e.velX *= -1; e.velY *= -1; sndHurt.play(); shakeScreen(); for (let i = 0; i < 5; i++) { particles.push(new Particle(this.x, this.y, { x: Math.random() * 8 - 4, y: Math.random() * 8 - 4 }, Math.random() * 6 + 1, { r: 255, g: 255, b: 255 }, 120)); } this.canBeHit = false; setTimeout(() => { this.canBeHit = true; }, 400); } } }); coins.forEach(c => { if (c.hitbox.intersects(this.hitbox)) { c.pickUp(); } }); if (this.x < 0) { this.x = 0; } if (this.x > canvas.width - 38) { this.x = canvas.width - 38; } if (this.y < 0) { this.y = 0; } if (this.y > canvas.height - 60) { this.y = canvas.height - 60; } this.trails.forEach((t, i) => { if (t.a <= 0) { this.trails.splice(i, 1); } t.update(); }); switch (this.skin) { case skins.default: case skins.mask: this.trails.push(new Trail(this.x, this.y, 32, 32, 255, 255, 255)); break; case skins.creeper: if (this.skinCreeperColor) { this.trails.push(new Trail(this.x, this.y, 32, 32, 0, 255, 9)); } else { this.trails.push(new Trail(this.x, this.y, 32, 32, 60, 60, 60)); } break; case skins.chicken: this.trails.push(new Trail(this.x, this.y, 32, 32, 255, 0, 0)); break; case skins.rainbow: let c = this.skinRainbowColors[this.skinRainbowColorIndex]; this.trails.push(new Trail(this.x, this.y, 32, 32, c.r, c.g, c.b)); break; } if (!options.showTrail) { this.trails = []; } } reset() { this.x = this.startX; this.y = this.startY; this.hp = 100; this.trails = []; nextLevel = 1000; level = 1; score = 0; scoreTotal = 0; coinCount = 0; } get hitbox() { return new Hitbox(this.x, this.y, 32, 32); } get hitboxInner() { return new Hitbox(this.x + 10, this.y + 10, 22, 22); } }